/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package net.ioixd.spigotjsongen;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

import org.bukkit.event.Event;
import org.reflections.Reflections;
import org.reflections.scanners.SubTypesScanner;

import com.google.gson.Gson;

import io.github.classgraph.ClassGraph;
import io.github.classgraph.ClassInfoList;
import io.github.classgraph.ScanResult;

public class App {
    public static void main(String[] args) throws IOException {
        String[][] packages = new String[][] {
            {"org.bukkit",
                    "org.bukkit.StructureType",
                    "org.bukkit.World$Environment",
                    "org.bukkit.BanList$Type",
                    "org.bukkit.plugin.ServicePriority",
                    "org.bukkit.entity.EnderDragon$Phase",
                    "org.bukkit.conversations.ConversationAbandonedEvent",
                    "org.bukkit.command.Command",
                    "org.bukkit.ChatColor",
                    "org.bukkit.enchantments.EnchantmentTarget",
                    "org.bukkit.entity.Spellcaster$Spell",
                    "org.bukkit.block.Lectern",
                    "org.bukkit.Warning$WarningState",
                    "org.bukkit.material.Directional",
                    "org.bukkit.material.Openable",
                    "org.bukkit.block.data.Directional",
                    "org.bukkit.entity.Damageable",
                    "org.bukkit.block.data.Ageable",
                    "org.bukkit.block.data.type.Sapling",
                    "org.bukkit.block.Furnace",
                    "org.bukkit.block.SculkSensor",
                    "org.bukkit.block.Sign",
                    "org.bukkit.structure.Structure",
                    "org.bukkit.block.data.type.StructureBlock$Mode",
                    "org.bukkit.packs.DataPack$Compatibility",
                    "org.bukkit.packs.DataPack$Source",
                    "org.bukkit.profile.PlayerTextures$SkinModel",
                    "org.bukkit.scoreboard.Team$Option",
                    "org.bukkit.scoreboard.Team$OptionStatus",
                    "org.bukkit.block.data.type.TechnicalPiston$Type",
                    "org.bukkit.block.data.type.Switch$Face",
                    "org.bukkit.block.data.type.Bamboo$Leaves",
                    "org.bukkit.block.data.type.Jigsaw$Orientation",
                    "org.bukkit.block.data.type.Wall$Height",
                    "org.bukkit.block.data.type.BigDripleaf$Tilt",
                    "org.bukkit.block.data.type.PointedDripstone$Thickness",
                    "org.bukkit.block.data.type.Slab$Type",
                    "org.bukkit.block.data.FaceAttachable$AttachedFace",
                    "org.bukkit.block.data.Rail$Shape",
                    "org.bukkit.block.data.Bisected$Half",
                    "org.bukkit.boss.DragonBattle$RespawnPhase",
                    "org.bukkit.entity.Ageable",
                    "org.bukkit.entity.MushroomCow$Variant",
                    "org.bukkit.entity.Panda$Gene",
                    "org.bukkit.entity.ItemDisplay$ItemDisplayTransform",
                    "org.bukkit.entity.AbstractArrow$PickupStatus",
                    "org.bukkit.entity.Skeleton$SkeletonType",
                    "org.bukkit.entity.Warden$AngerLevel",
                    "org.bukkit.entity.Rabbit$Type",
                    "org.bukkit.entity.TextDisplay$TextAlignment",
                    "org.bukkit.entity.TropicalFish$Pattern",
                    "org.bukkit.entity.Wither$Head",
                    "org.bukkit.entity.Llama$Color",
                    "org.bukkit.entity.Boat$Status",
                    "org.bukkit.entity.Boat$Type",
                    "org.bukkit.entity.Display$Billboard",
                    "org.bukkit.entity.Horse$Variant",
                    "org.bukkit.entity.Horse$Color",
                    "org.bukkit.entity.Horse$Style",
                    "org.bukkit.entity.FishHook$HookState",
                    "org.bukkit.entity.Parrot$Variant",
                    "org.bukkit.entity.Evoker$Spell",
                    "org.bukkit.entity.Fox$Type",
                    "org.bukkit.entity.Ocelot$Type",
                    "org.bukkit.entity.Cat$Type",
                    "org.bukkit.entity.Axolotl$Variant", 
                    "org.bukkit.entity.ArmorStand$LockType",
                    "org.bukkit.entity.Sniffer$State",
                    "org.bukkit.Chunk$LoadLevel",
                    "org.bukkit.Raid$RaidStatus",
                    "org.bukkit.map.MapView$Scale",
                    "org.bukkit.block.Jukebox",
                    "org.bukkit.inventory.meta.BookMeta$Generation"
            },
            {"net.md_5",
                    "net.md_5.bungee.chat.TranslationRegistry$TranslationProvider"}
        };
        HashMap<String, Object> parsed_packages = new HashMap<>();

        for(String[] pkg : packages) {
            String[] oh = new String[] {};
            if(pkg.length >= 1) {
                oh = Arrays.copyOfRange(pkg, 1, pkg.length);
            }
            parsed_packages.put(pkg[0], packageMap(pkg[0], oh));
        }

        File dest_file = new File("../spigot.json");
        dest_file.createNewFile();

        FileWriter dest = new FileWriter("../spigot.json");
        String json = new Gson().toJson(parsed_packages);
        dest.write(json, 0, json.length());
        dest.close();
    }

    public static HashMap<String,HashMap<String,Object>> packageMap(String packageName, String[] lostImports) {
        ClassGraph clsgraph = new ClassGraph();
        clsgraph.acceptPackages(packageName);
        clsgraph.initializeLoadedClasses();
        ScanResult scan = clsgraph.scan();

        HashMap<String, HashMap<String,Object>> all = new HashMap<>();

        // Reflections actually sucks but so does ClassGraph, it just sucks less, so we need to use this as a fallback
        Reflections reflections = new Reflections(packageName, new SubTypesScanner(false));
        HashMap<String, Class<? extends Object>> reflectionsmap = new HashMap<>();
        HashMap<String, Enum<?>> enummap = new HashMap<>();
        for(Class<? extends Object> cls : reflections.getSubTypesOf(Object.class)) {
            reflectionsmap.put(cls.getName(), cls);
        }

        // ============================
        // CLASSES AND INTERFACES
        // ============================
        ArrayList<ParsedClass> classes = new ArrayList<ParsedClass>(); 
        ClassInfoList classes_raw = scan.getAllClasses();
        classes_raw.forEach(cls -> {
            cls.loadClass(true);
        });
        classes_raw.forEach(cls -> {
            Class<?> c = cls.loadClass(true);
            if(c == null) {
                try {
                    cls.loadClass(false);
                } catch(Exception ex) {
                    try {
                        // try loading it through Reflections instead.
                        classes.add(new ParsedClass(reflectionsmap.get(cls.getName())));
                        return;
                    } catch(Exception ex2) {
                        ex.printStackTrace();
                        System.out.println("An additional error occured when trying to use Reflections:");
                        ex2.printStackTrace();
                        return;
                    }
                }
            }
            classes.add(new ParsedClass(c));
        });
        ClassInfoList interfaces = scan.getAllInterfaces();
        interfaces.forEach(cls -> {
            Class<?> c = cls.loadClass(true);
            if(c == null) {
                try {
                    cls.loadClass(false);
                } catch(Exception ex) {
                    try {
                        // try loading it through Reflections instead.
                        classes.add(new ParsedClass(reflectionsmap.get(cls.getName())));
                        return;
                    } catch(Exception ex2) {
                        ex.printStackTrace();
                        System.out.println("An additional error occured when trying to use Reflections:");
                        ex2.printStackTrace();
                        return;
                    }
                }
            }
            classes.add(new ParsedClass(c));
        });

        for (String importStr : lostImports) {
            Class<?> what;
            try {
                what = Class.forName(importStr);
                classes.add(new ParsedClass(what));
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
                System.exit(1);
            }
        }

        HashMap<String, ParsedClass> classes_part_2 = new HashMap<>();

        classes.forEach(c -> {
            classes_part_2.put(c.name, c);
        });

        classes_part_2.keySet().forEach(c -> {
            ParsedClass cls = classes_part_2.get(c);
            if(all.get(cls.packageName) == null) {
                all.put(cls.packageName, new HashMap<>());
            }
            all.get(cls.packageName).put(c, cls);
        });
        
        // ============================
        // ENUMS
        // ============================
        ArrayList<Enum<?>> enum_objects = new ArrayList<>();
        ClassInfoList enums_raw = scan.getSubclasses(Enum.class.getName());
        enums_raw.getEnums().forEach(en -> {
            Class<?> e = en.loadClass(true);
            if(e == null) {
                try {
                    en.loadClass(false);
                } catch(Exception ex) {
                    try {
                        enum_objects.add(enummap.get(en.getName()));
                    } catch(Exception ex2) {
                        ex.printStackTrace();
                        System.out.println("An additional error occured when trying to use Reflections:");
                        ex2.printStackTrace();
                        return;
                    }
                }
            }
            try {
                Method valueOf = e.getDeclaredMethod("valueOf", String.class);
                String value = e.getEnumConstants()[0].toString();
                if(value.toUpperCase() != value) {
                    value = value.replaceAll("([A-Z])", "_$1").toUpperCase();
                }
                enum_objects.add((Enum<?>) valueOf.invoke(null, value));
            } catch(InvocationTargetException ignored) {
            } catch (IllegalAccessException | IllegalArgumentException
                    | NoSuchMethodException | SecurityException e1) {
                String value = e.getEnumConstants()[0].toString();
                System.out.println(value);
                e1.printStackTrace();
            }
        });


        ArrayList<ParsedEnum> enums = new ArrayList<ParsedEnum>();
        for(Enum<?> e : enum_objects) {
            enums.add(new ParsedEnum(e));
        }

        HashMap<String, ParsedEnum> enums_part_2 = new HashMap<>();

        enums.forEach(c -> {
            enums_part_2.put(c.name, c);
        });

        enums_part_2.keySet().forEach(c -> {
            ParsedEnum e = enums_part_2.get(c);
            if(all.get(e.packageName) == null) {
                all.put(e.packageName, new HashMap<>());
            }
            all.get(e.packageName).put(c, e);
        });

        return all;
    }
}
